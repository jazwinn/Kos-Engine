/******************************************************************/
/*!
\file      ImGuiHandler.cpp
\author    Sean Tiu
\par       s.tiu@digipen.edu
\date      2nd Oct, 2024
\brief

           This file contains the implementation of the `ImGuiHandler`
           class method `m_DrawRenderScreenWindow`, which is responsible
           for rendering a scene window using ImGui. The scene is displayed
           as an OpenGL texture generated by the framebuffer inside an ImGui window, 
           scaled to maintain the correct aspect ratio of the rendered image based 
           on the window's size.

           The function calculates the appropriate size and position
           for the image within the window to ensure that the aspect ratio
           of the texture is preserved, even when the window is resized.

Copyright (C) 2024 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/******************************************************************/

#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "imgui_handler.h"
#include "../ECS/ECS.h"
#include "../Application/Application.h"

#include "../Graphics/GraphicsPipe.h"
#include "../Graphics/GraphicsCamera.h"

void gui::ImGuiHandler::m_DrawRenderScreenWindow(unsigned int windowWidth, unsigned int windowHeight)
{

    graphicpipe::GraphicsPipe* pipe = graphicpipe::GraphicsPipe::m_funcGetInstance();
    //graphicpipe::GraphicsCamera* cam = graphicpipe::GraphicsCamera::m_funcGetInstance();
    
    ImGui::Begin("Scene Window");

    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImVec2 renderWindowSize = ImGui::GetContentRegionAvail();

    float textureAspectRatio = (float)windowWidth / (float)windowHeight;
    float renderWindowAspectRatio = renderWindowSize.x / renderWindowSize.y;

    ImVec2 imageSize;
    imageSize.x = windowWidth / 2;
    imageSize.y = windowHeight / 2;



   if (renderWindowAspectRatio > textureAspectRatio) 
    {
        imageSize.y = renderWindowSize.y;
        imageSize.x = imageSize.y * textureAspectRatio;
    }
    else 
    {
        imageSize.x = renderWindowSize.x;
        imageSize.y = imageSize.x / textureAspectRatio;
    }

    if (imageSize.x <= renderWindowSize.x)
    {
        pos.x += (renderWindowSize.x - imageSize.x) / 2;
    }

    if (imageSize.y <= renderWindowSize.y)
    {
        pos.y += (renderWindowSize.y - imageSize.y) / 2;
    }


    ImGui::GetWindowDrawList()->AddImage(
        (void*)(long long unsigned int)pipe->m_screenTexture, pos,
        ImVec2(pos.x + imageSize.x, pos.y + imageSize.y),
        ImVec2(0, 1), ImVec2(1, 0));

    //draw gizmo
    m_DrawGizmo(pos.x, pos.y, imageSize.x, imageSize.y);

    float scrollInput = ImGui::GetIO().MouseWheel; // Positive for zoom in, negative for zoom out
     
    graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.x += scrollInput * graphicpipe::GraphicsCamera::m_editorCameraZoomSensitivity;
    graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.y += scrollInput * graphicpipe::GraphicsCamera::m_editorCameraZoomSensitivity;

    graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.x = glm::clamp(graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.x, 0.1f, 10.f);
    graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.y = glm::clamp(graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.y, 0.1f, 10.f);

    if (ImGui::IsMouseDragging(ImGuiMouseButton_Right) && ImGui::IsWindowHovered())
    {
        ImVec2 mouseDelta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);

        glm::vec2 delta = glm::vec2(mouseDelta.x, mouseDelta.y) * graphicpipe::GraphicsCamera::m_editorCameraDragSensitivity;

        // Update the camera position
        graphicpipe::GraphicsCamera::m_editorCamera.m_coordinates.x -= delta.x;
        graphicpipe::GraphicsCamera::m_editorCamera.m_coordinates.y += delta.y;
     
        ImGui::ResetMouseDragDelta(ImGuiMouseButton_Right);
    }

    //Reset Camera To Center
    if (ImGui::IsKeyPressed(ImGuiKey_R) && ImGui::IsKeyDown(ImGuiKey_LeftCtrl))
    {
        graphicpipe::GraphicsCamera::m_editorCamera.m_coordinates.x = 0.f;
        graphicpipe::GraphicsCamera::m_editorCamera.m_coordinates.y = 0.f;
        graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.x = 1.f;
        graphicpipe::GraphicsCamera::m_editorCamera.m_zoom.y = 1.f;
    }

    ImGui::End();
   
}


