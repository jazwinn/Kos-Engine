/******************************************************************/
/*!
\file      ImGuiHandler.cpp
\author    Sean Tiu
\par       s.tiu@digipen.edu
\date      2nd Oct, 2024
\brief

           This file contains the implementation of the `ImGuiHandler`
           class method `m_DrawRenderScreenWindow`, which is responsible
           for rendering a scene window using ImGui. The scene is displayed
           as an OpenGL texture generated by the framebuffer inside an ImGui window, 
           scaled to maintain the correct aspect ratio of the rendered image based 
           on the window's size.

           The function calculates the appropriate size and position
           for the image within the window to ensure that the aspect ratio
           of the texture is preserved, even when the window is resized.

Copyright (C) 2024 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/******************************************************************/

#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "imgui_handler.h"
#include "imgui_internal.h"


#include "../ECS/ECS.h"
#include "../Application/Application.h"

#include "../Graphics/GraphicsPipe.h"
#include "../Graphics/GraphicsCamera.h"
#include "../Editor/EditorCamera.h"



void gui::ImGuiHandler::m_DrawRenderScreenWindow(unsigned int windowWidth, unsigned int windowHeight)
{
    graphicpipe::GraphicsPipe* pipe = graphicpipe::GraphicsPipe::m_funcGetInstance();
    //EditorCamera* cam = EditorCamera::m_funcGetInstance();
   //pipe->m_funcUpdate();
   

    ImGui::Begin("Scene Window");

    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImVec2 renderWindowSize = ImGui::GetContentRegionAvail();

    float textureAspectRatio = (float)windowWidth / (float)windowHeight;
    float renderWindowAspectRatio = renderWindowSize.x / renderWindowSize.y;

    ImVec2 imageSize;
    imageSize.x = windowWidth / 2;
    imageSize.y = windowHeight / 2;


   if (renderWindowAspectRatio > textureAspectRatio) 
    {
        imageSize.y = renderWindowSize.y;
        imageSize.x = imageSize.y * textureAspectRatio;
    }
    else 
    {
        imageSize.x = renderWindowSize.x;
        imageSize.y = imageSize.x / textureAspectRatio;
    }

    if (imageSize.x <= renderWindowSize.x)
    {
        pos.x += (renderWindowSize.x - imageSize.x) / 2;
    }

    if (imageSize.y <= renderWindowSize.y)
    {
        pos.y += (renderWindowSize.y - imageSize.y) / 2;
    }


    ImGui::GetWindowDrawList()->AddImage(
        (void*)(long long unsigned int)pipe->m_screenTexture, pos,
        ImVec2(pos.x + imageSize.x, pos.y + imageSize.y),
        ImVec2(0, 1), ImVec2(1, 0));



    float scrollInput = ImGui::GetIO().MouseWheel; // Positive for zoom in, negative for zoom out
     
    EditorCamera::m_editorCamera.m_zoom.x -= scrollInput * EditorCamera::m_editorCameraZoomSensitivity;
    EditorCamera::m_editorCamera.m_zoom.y -= scrollInput * EditorCamera::m_editorCameraZoomSensitivity;

    EditorCamera::m_editorCamera.m_zoom.x = glm::clamp(EditorCamera::m_editorCamera.m_zoom.x, 0.1f, 10.f);
    EditorCamera::m_editorCamera.m_zoom.y = glm::clamp(EditorCamera::m_editorCamera.m_zoom.y, 0.1f, 10.f);

    if (ImGui::IsMouseDragging(ImGuiMouseButton_Right) && ImGui::IsWindowHovered())
    {
        ImVec2 mouseDelta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);

        glm::vec2 delta = glm::vec2(mouseDelta.x, mouseDelta.y) * EditorCamera::m_editorCameraDragSensitivity;

        // Update the camera position
        EditorCamera::m_editorCamera.m_coordinates.x -= delta.x;
        EditorCamera::m_editorCamera.m_coordinates.y += delta.y;
     
        ImGui::ResetMouseDragDelta(ImGuiMouseButton_Right);
    }

    //Reset Camera To Center
    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyDown(ImGuiKey_R))
    {
        EditorCamera::m_editorCamera.m_coordinates.x = 0.f;
        EditorCamera::m_editorCamera.m_coordinates.y = 0.f;
        EditorCamera::m_editorCamera.m_zoom.x = 1.f;
        EditorCamera::m_editorCamera.m_zoom.y = 1.f;
    }
    EditorCamera::calculateLevelEditorCamera();
    EditorCamera::calculateLevelEditorView();
    EditorCamera::calculateLevelEditorOrtho();
    graphicpipe::GraphicsCamera::m_currCameraMatrix = EditorCamera::m_editorCameraMatrix;
    graphicpipe::GraphicsCamera::m_currViewMatrix = EditorCamera::m_editorViewMatrix;
    
    //draw gizmo
    m_DrawGizmo(pos.x, pos.y, imageSize.x, imageSize.y);
    
    ImGui::Dummy(renderWindowSize);
    if (ImGui::BeginDragDropTarget())
    {

        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("file"))
        {
            IM_ASSERT(payload->DataSize == sizeof(std::filesystem::path));
            std::filesystem::path* filename = static_cast<std::filesystem::path*>(payload->Data);

            float screencordX = ImGui::GetMousePos().x - pos.x;
            float screencordY = ImGui::GetMousePos().y - pos.y;

            //TODO calculate mouse pos correctly
            float cordX = (screencordX - imageSize.x / 2.f) / (imageSize.x / 2.f);
            float cordY = (std::abs(screencordY) - imageSize.y / 2.f) / (imageSize.y / 2.f);

            glm::vec3 translate = { cordX , -cordY, 0.f };
            translate.x *= EditorCamera::m_editorCameraMatrix[0][0];
            translate.y *= EditorCamera::m_editorCameraMatrix[1][1];
            translate.x *= 1.f / graphicpipe::GraphicsCamera::m_aspectRatio;
            translate.x += EditorCamera::m_editorCameraMatrix[2][0];
            translate.y += EditorCamera::m_editorCameraMatrix[2][1];
            

            if (filename->filename().extension().string() == ".png") {
             ecs::ECS* ecs = ecs::ECS::m_GetInstance();
                ecs::EntityID id = ecs->m_CreateEntity(ecs->m_ECS_SceneMap.begin()->first); //assign to top most scene
                ecs::TransformComponent* transCom = static_cast<ecs::TransformComponent*>(ecs->m_ECS_CombinedComponentPool[ecs::TYPETRANSFORMCOMPONENT]->m_GetEntityComponent(id));
                transCom->m_position = { translate.x, translate.y };
                // Insert matrix
                ecs::NameComponent* nameCom = static_cast<ecs::NameComponent*>(ecs->m_ECS_CombinedComponentPool[ecs::TYPENAMECOMPONENT]->m_GetEntityComponent(id));
                nameCom->m_entityName = filename->filename().stem().string();
                ecs::SpriteComponent * spriteCom = static_cast<ecs::SpriteComponent*>(ecs->m_AddComponent(ecs::TYPESPRITECOMPONENT, id));
                spriteCom->m_imageFile = filename->filename().string();

                m_clickedEntityId = id;
            }
            if (filename->filename().extension().string() == ".ttf") {
                ecs::ECS* ecs = ecs::ECS::m_GetInstance();
                ecs::EntityID id = ecs->m_CreateEntity(ecs->m_ECS_SceneMap.begin()->first); //assign to top most scene
                ecs::TransformComponent* transCom = static_cast<ecs::TransformComponent*>(ecs->m_ECS_CombinedComponentPool[ecs::TYPETRANSFORMCOMPONENT]->m_GetEntityComponent(id));
                transCom->m_position = { translate.x, translate.y };
                // Insert matrix
                ecs::NameComponent* nameCom = static_cast<ecs::NameComponent*>(ecs->m_ECS_CombinedComponentPool[ecs::TYPENAMECOMPONENT]->m_GetEntityComponent(id));
                nameCom->m_entityName = filename->filename().stem().string();
                ecs::TextComponent* textCom = static_cast<ecs::TextComponent*>(ecs->m_AddComponent(ecs::TYPETEXTCOMPONENT, id));
                textCom->m_fileName = filename->filename().string();

                m_clickedEntityId = id;
            }


        }
        ImGui::EndDragDropTarget();
    }


    ImGui::End();


}



